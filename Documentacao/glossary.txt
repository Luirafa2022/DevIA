Glossário
*********

">>>"
   O prompt padrão do console interativo do Python. Normalmente visto
   em exemplos de código que podem ser executados interativamente no
   interpretador.

"..."
   Pode se referir a:

   * O prompt padrão do shell interativo do Python ao inserir o código
     para um bloco de código recuado, quando dentro de um par de
     delimitadores correspondentes esquerdo e direito (parênteses,
     colchetes, chaves ou aspas triplas) ou após especificar um
     decorador.

   * A constante embutida "Ellipsis".

2to3
   Uma ferramenta que tenta converter código Python 2.x em código
   Python 3.x tratando a maioria das incompatibilidades que podem ser
   detectadas com análise do código-fonte e navegação na árvore
   sintática.

   O 2to3 está disponível na biblioteca padrão como "lib2to3"; um
   ponto de entrada é disponibilizado como "Tools/scripts/2to3". Veja
   2to3 --- Tradução Automatizada de Código Python 2 para 3.

classe base abstrata
   Classes bases abstratas complementam *tipagem pato*, fornecendo uma
   maneira de definir interfaces quando outras técnicas, como
   "hasattr()", seriam desajeitadas ou sutilmente erradas (por
   exemplo, com métodos mágicos). CBAs introduzem subclasses virtuais,
   classes que não herdam de uma classe mas ainda são reconhecidas por
   "isinstance()" e "issubclass()"; veja a documentação do módulo
   "abc". Python vem com muitas CBAs embutidas para estruturas de
   dados (no módulo "collections.abc"), números (no módulo "numbers"),
   fluxos (no módulo "io"), localizadores e carregadores de importação
   (no módulo "importlib.abc"). Você pode criar suas próprias CBAs com
   o módulo "abc".

anotação
   Um rótulo associado a uma variável, um atributo de classe ou um
   parâmetro de função ou valor de retorno, usado por convenção como
   *dica de tipo*.

   Anotações de variáveis ​​locais não podem ser acessadas em tempo de
   execução, mas anotações de variáveis ​​globais, atributos de classe
   e funções são armazenadas no atributo especial "__annotations__" de
   módulos, classes e funções, respectivamente.

   Veja *anotação de variável*, *anotação de função*, **PEP 484** e
   **PEP 526**, que descrevem esta funcionalidade. Veja também Boas
   Práticas de Anotação para as melhores práticas sobre como trabalhar
   com anotações.

argumento
   Um valor passado para uma *função* (ou *método*) ao chamar a
   função. Existem dois tipos de argumento:

   * *argumento nomeado*: um argumento precedido por um identificador
     (por exemplo, "name=") na chamada de uma função ou passada como
     um valor em um dicionário precedido por "**". Por exemplo, "3" e
     "5" são ambos argumentos nomeados na chamada da função
     "complex()" a seguir:

        complex(real=3, imag=5)
        complex(**{'real': 3, 'imag': 5})

   * *argumento posicional*: um argumento que não é um argumento
     nomeado. Argumentos posicionais podem aparecer no início da lista
     de argumentos e/ou podem ser passados com elementos de um
     *iterável* precedido por "*". Por exemplo, "3" e "5" são ambos
     argumentos posicionais nas chamadas a seguir:

        complex(3, 5)
        complex(*(3, 5))

   Argumentos são atribuídos às variáveis locais nomeadas no corpo da
   função. Veja a seção Chamadas para as regras de atribuição.
   Sintaticamente, qualquer expressão pode ser usada para representar
   um argumento; avaliada a expressão, o valor é atribuído à variável
   local.

   Veja também o termo *parâmetro* no glossário, a pergunta no FAQ
   sobre a diferença entre argumentos e parâmetros e **PEP 362**.

gerenciador de contexto assíncrono
   Um objeto que controla o ambiente visto numa instrução "async with"
   por meio da definição dos métodos "__aenter__()" e "__aexit__()".
   Introduzido pela **PEP 492**.

gerador assíncrono
   Uma função que retorna um *iterador gerador assíncrono*. É parecida
   com uma função de corrotina definida com "async def" exceto pelo
   fato de conter instruções "yield" para produzir uma série de
   valores que podem ser usados em um laço "async for".

   Normalmente se refere a uma função geradora assíncrona, mas pode se
   referir a um *iterador gerador assíncrono* em alguns contextos. Em
   casos em que o significado não esteja claro, usar o termo completo
   evita a ambiguidade.

   Uma função geradora assíncrona pode conter expressões "await" e
   também as instruções "async for" e "async with".

iterador gerador assíncrono
   Um objeto criado por uma função *geradora assíncrona*.

   Este é um *iterador assíncrono* que, quando chamado usando o método
   "__anext__()", retorna um objeto aguardável que executará o corpo
   da função geradora assíncrona até a próxima expressão "yield".

   Cada "yield" suspende temporariamente o processamento, lembrando o
   estado de execução do local (incluindo variáveis locais e
   instruções "try" pendentes). Quando o *iterador gerador assíncrono*
   é efetivamente retomado com outro aguardável retornado por
   "__anext__()", ele inicia de onde parou. Veja **PEP 492** e **PEP
   525**.

iterável assíncrono
   Um objeto que pode ser usado em uma instrução "async for". Deve
   retornar um *iterador assíncrono* do seu método "__aiter__()".
   Introduzido por **PEP 492**.

iterador assíncrono
   Um objeto que implementa os métodos "__aiter__()" e "__anext__()".
   "__anext__()" deve retornar um objeto *aguardável*. "async for"
   resolve os aguardáveis retornados por um método "__anext__()" do
   iterador assíncrono até que ele levante uma exceção
   "StopAsyncIteration". Introduzido pela **PEP 492**.

atributo
   Um valor associado a um objeto que é geralmente referenciado pelo
   nome separado por um ponto. Por exemplo, se um objeto *o* tem um
   atributo *a* esse seria referenciado como *o.a*.

   É possível dar a um objeto um atributo cujo nome não seja um
   identificador conforme definido por Identificadores e palavras-
   chave, por exemplo usando "setattr()", se o objeto permitir. Tal
   atributo não será acessível usando uma expressão pontilhada e, em
   vez disso, precisaria ser recuperado com "getattr()".

aguardável
   Um objeto que pode ser usado em uma expressão "await". Pode ser uma
   *corrotina* ou um objeto com um método "__await__()". Veja também a
   **PEP 492**.

BDFL
   Abreviação da expressão da língua inglesa "Benevolent Dictator for
   Life" (em português, "Ditador Benevolente Vitalício"), referindo-se
   a Guido van Rossum, criador do Python.

arquivo binário
   Um *objeto arquivo* capaz de ler e gravar em *objetos bytes ou
   similar*. Exemplos de arquivos binários são arquivos abertos no
   modo binário ("'rb'", "'wb'" ou "'rb+'"), "sys.stdin.buffer",
   "sys.stdout.buffer", e instâncias de "io.BytesIO" e
   "gzip.GzipFile".

   Veja também *arquivo texto* para um objeto arquivo capaz de ler e
   gravar em objetos "str".

referência emprestada
   Na API C do Python, uma referência emprestada é uma referência a um
   objeto que não é dona da referência. Ela se torna um ponteiro solto
   se o objeto for destruído. Por exemplo, uma coleta de lixo pode
   remover a última *referência forte* para o objeto e assim
   destruí-lo.

   Chamar "Py_INCREF()" na *referência emprestada* é recomendado para
   convertê-lo, internamente, em uma *referência forte*, exceto quando
   o objeto não pode ser destruído antes do último uso da referência
   emprestada. A função "Py_NewRef()" pode ser usada para criar uma
   nova *referência forte*.

objeto byte ou similar
   Um objeto com suporte ao o Protocolo de Buffer e que pode exportar
   um buffer C *contíguo*. Isso inclui todos os objetos "bytes",
   "bytearray" e "array.array", além de muitos objetos  "memoryview"
   comuns. Objetos byte ou similar podem ser usados para várias
   operações que funcionam com dados binários; isso inclui
   compactação, salvamento em um arquivo binário e envio por um
   soquete.

   Algumas operações precisam que os dados binários sejam mutáveis. A
   documentação geralmente se refere a eles como "objetos byte ou
   similar para leitura e escrita". Exemplos de objetos de buffer
   mutável incluem "bytearray" e um "memoryview" de um "bytearray".
   Outras operações exigem que os dados binários sejam armazenados em
   objetos imutáveis ("objetos byte ou similar para somente leitura");
   exemplos disso incluem "bytes" e a "memoryview" de um objeto
   "bytes".

bytecode
   O código-fonte Python é compilado para bytecode, a representação
   interna de um programa em Python no interpretador CPython. O
   bytecode também é mantido em cache em arquivos ".pyc" e ".pyo", de
   forma que executar um mesmo arquivo é mais rápido na segunda vez (a
   recompilação dos fontes para bytecode não é necessária). Esta
   "linguagem intermediária" é adequada para execução em uma *máquina
   virtual*, que executa o código de máquina correspondente para cada
   bytecode. Tenha em mente que não se espera que bytecodes sejam
   executados entre máquinas virtuais Python diferentes, nem que se
   mantenham estáveis entre versões de Python.

   Uma lista de instruções bytecode pode ser encontrada na
   documentação para o módulo dis.

chamável
   Um chamável é um objeto que pode ser chamado, possivelmente com um
   conjunto de argumentos (veja *argumento*), com a seguinte sintaxe:

      callable(argument1, argument2, argumentN)

   Uma *função*, e por extensão um *método*, é um chamável. Uma
   instância de uma classe que implementa o método "__call__()" também
   é um chamável.

função de retorno
   Também conhecida como callback, é uma função sub-rotina que é
   passada como um argumento a ser executado em algum ponto no futuro.

classe
   Um modelo para criação de objetos definidos pelo usuário.
   Definições de classe normalmente contém definições de métodos que
   operam sobre instâncias da classe.

variável de classe
   Uma variável definida em uma classe e destinada a ser modificada
   apenas no nível da classe (ou seja, não em uma instância da
   classe).

número complexo
   Uma extensão ao familiar sistema de números reais em que todos os
   números são expressos como uma soma de uma parte real e uma parte
   imaginária. Números imaginários são múltiplos reais da unidade
   imaginária (a raiz quadrada de "-1"), normalmente escrita como "i"
   em matemática ou "j" em engenharia. O Python tem suporte nativo
   para números complexos, que são escritos com esta última notação; a
   parte imaginária escrita com um sufixo "j", p.ex., "3+1j". Para ter
   acesso aos equivalentes para números complexos do módulo "math",
   utilize "cmath". O uso de números complexos é uma funcionalidade
   matemática bastante avançada. Se você não sabe se irá precisar
   deles, é quase certo que você pode ignorá-los sem problemas.

gerenciador de contexto
   Um objeto que controla o ambiente visto numa instrução "with" por
   meio da definição dos métodos "__enter__()" e "__exit__()". Veja
   **PEP 343**.

variável de contexto
   Uma variável que pode ter valores diferentes, dependendo do seu
   contexto. Isso é semelhante ao armazenamento local de threads, no
   qual cada thread pode ter um valor diferente para uma variável. No
   entanto, com variáveis de contexto, pode haver vários contextos em
   uma thread e o principal uso para variáveis de contexto é
   acompanhar as variáveis em tarefas assíncronas simultâneas. Veja
   "contextvars".

contíguo
   Um buffer é considerado contíguo exatamente se for *contíguo C* ou
   *contíguo Fortran*. Os buffers de dimensão zero são contíguos C e
   Fortran. Em vetores unidimensionais, os itens devem ser dispostos
   na memória próximos um do outro, em ordem crescente de índices,
   começando do zero. Em vetores multidimensionais contíguos C, o
   último índice varia mais rapidamente ao visitar itens em ordem de
   endereço de memória. No entanto, nos vetores contíguos do Fortran,
   o primeiro índice varia mais rapidamente.

corrotina
   Corrotinas são uma forma mais generalizada de sub-rotinas. Sub-
   rotinas tem a entrada iniciada em um ponto, e a saída em outro
   ponto. Corrotinas podem entrar, sair, e continuar em muitos pontos
   diferentes. Elas podem ser implementadas com a instrução "async
   def". Veja também **PEP 492**.

função de corrotina
   Uma função que retorna um objeto do tipo *corrotina*. Uma função de
   corrotina pode ser definida com a instrução "async def", e pode
   conter as palavras chaves "await", "async for", e "async with".
   Isso foi introduzido pela **PEP 492**.

CPython
   A implementação canônica da linguagem de programação Python, como
   disponibilizada pelo python.org. O termo "CPython" é usado quando
   necessário distinguir esta implementação de outras como Jython ou
   IronPython.

decorador
   Uma função que retorna outra função, geralmente aplicada como uma
   transformação de função usando a sintaxe "@wrapper". Exemplos
   comuns para decoradores são "classmethod()" e "staticmethod()".

   A sintaxe do decorador é meramente um açúcar sintático, as duas
   definições de funções a seguir são semanticamente equivalentes:

      def f(arg):
          ...
      f = staticmethod(f)

      @staticmethod
      def f(arg):
          ...

   O mesmo conceito existe para as classes, mas não é comumente
   utilizado. Veja a documentação de definições de função e definições
   de classe para obter mais informações sobre decoradores.

descritor
   Qualquer objeto que define os métodos "__get__()", "__set__()" ou
   "__delete__()". Quando um atributo de classe é um descritor, seu
   comportamento de associação especial é acionado no acesso a um
   atributo. Normalmente, ao se utilizar *a.b* para se obter, definir
   ou excluir, um atributo dispara uma busca no objeto chamado *b* no
   dicionário de classe de *a*, mas se *b* for um descritor, o
   respectivo método descritor é chamado. Compreender descritores é a
   chave para um profundo entendimento de Python pois eles são a base
   de muitas funcionalidades incluindo funções, métodos, propriedades,
   métodos de classe, métodos estáticos e referências para
   superclasses.

   Para obter mais informações sobre os métodos dos descritores, veja:
   Implementando descritores ou o Guia de Descritores.

dicionário
   Um vetor associativo em que chaves arbitrárias são mapeadas para
   valores. As chaves podem ser quaisquer objetos que possuam os
   métodos "__hash__()" e "__eq__()". Isso é chamado de hash em Perl.

compreensão de dicionário
   Uma maneira compacta de processar todos ou parte dos elementos de
   um iterável e retornar um dicionário com os resultados. "results =
   {n: n ** 2 for n in range(10)}" gera um dicionário contendo a chave
   "n" mapeada para o valor "n ** 2". Veja Sintaxe de criação de
   listas, conjuntos e dicionários.

visão de dicionário
   Os objetos retornados por "dict.keys()", "dict.values()" e
   "dict.items()" são chamados de visões de dicionário. Eles fornecem
   uma visão dinâmica das entradas do dicionário, o que significa que
   quando o dicionário é alterado, a visão reflete essas alterações.
   Para forçar a visão de dicionário a se tornar uma lista completa
   use "list(dictview)". Veja Objetos de visão de dicionário.

docstring
   Abreviatura de "documentation string" (string de documentação). Uma
   string literal que aparece como primeira expressão numa classe,
   função ou módulo. Ainda que sejam ignoradas quando a suíte é
   executada, é reconhecida pelo compilador que a coloca no atributo
   "__doc__" da classe, função ou módulo que a encapsula. Como ficam
   disponíveis por meio de introspecção, docstrings são o lugar
   canônico para documentação do objeto.

tipagem pato
   Também conhecida como *duck-typing*, é um estilo de programação que
   não verifica o tipo do objeto para determinar se ele possui a
   interface correta; em vez disso, o método ou atributo é
   simplesmente chamado ou utilizado ("Se se parece com um pato e
   grasna como um pato, então deve ser um pato.") Enfatizando
   interfaces ao invés de tipos específicos, o código bem desenvolvido
   aprimora sua flexibilidade por permitir substituição polimórfica.
   Tipagem pato evita necessidade de testes que usem "type()" ou
   "isinstance()". (Note, porém, que a tipagem pato pode ser
   complementada com o uso de *classes base abstratas*.) Ao invés
   disso, são normalmente empregados testes "hasattr()" ou programação
   *EAFP*.

EAFP
   Iniciais da expressão em inglês "easier to ask for forgiveness than
   permission" que significa "é mais fácil pedir perdão que
   permissão". Este estilo de codificação comum em Python assume a
   existência de chaves ou atributos válidos e captura exceções caso
   essa premissa se prove falsa. Este estilo limpo e rápido se
   caracteriza pela presença de várias instruções "try" e "except". A
   técnica diverge do estilo *LBYL*, comum em outras linguagens como
   C, por exemplo.

expressão
   Uma parte da sintaxe que pode ser avaliada para algum valor. Em
   outras palavras, uma expressão é a acumulação de elementos de
   expressão como literais, nomes, atributos de acesso, operadores ou
   chamadas de funções, todos os quais retornam um valor. Em contraste
   com muitas outras linguagens, nem todas as construções de linguagem
   são expressões. Também existem *instruções*, as quais não podem ser
   usadas como expressões, como, por exemplo, "while". Atribuições
   também são instruções, não expressões.

módulo de extensão
   Um módulo escrito em C ou C++, usando a API C do Python para
   interagir tanto com código de usuário quanto do núcleo.

f-string
   Literais string prefixadas com "'f'" ou "'F'" são conhecidas como
   "f-strings" que é uma abreviação de formatted string literals. Veja
   também **PEP 498**.

objeto arquivo
   Um objeto que expõe uma API orientada a arquivos (com métodos tais
   como "read()" ou "write()") para um recurso subjacente. Dependendo
   da maneira como foi criado, um objeto arquivo pode mediar o acesso
   a um arquivo real no disco ou outro tipo de dispositivo de
   armazenamento ou de comunicação (por exemplo a entrada/saída
   padrão, buffers em memória, soquetes, pipes, etc.). Objetos arquivo
   também são chamados de *objetos arquivo ou similares* ou *fluxos*.

   Atualmente há três categorias de objetos arquivo: *arquivos
   binários* brutos, *arquivos binários* em buffer e *arquivos
   textos*. Suas interfaces estão definidas no módulo "io". A forma
   canônica para criar um objeto arquivo é usando a função "open()".

objeto arquivo ou similar
   Um sinônimo do termo *objeto arquivo*.

tratador de erros e codificação do sistema de arquivos
   Tratador de erros e codificação usado pelo Python para decodificar
   bytes do sistema operacional e codificar Unicode para o sistema
   operacional.

   A codificação do sistema de arquivos deve garantir a decodificação
   bem-sucedida de todos os bytes abaixo de 128. Se a codificação do
   sistema de arquivos falhar em fornecer essa garantia, as funções da
   API podem levantar "UnicodeError".

   As funções "sys.getfilesystemencoding()" e
   "sys.getfilesystemencodeerrors()" podem ser usadas para obter o
   tratador de erros e codificação do sistema de arquivos.

   O *tratador de erros e codificação do sistema de arquivos* são
   configurados na inicialização do Python pela função
   "PyConfig_Read()": veja os membros "filesystem_encoding" e
   "filesystem_errors" do "PyConfig".

   Veja também *codificação da localidade*.

localizador
   Um objeto que tenta encontrar o *carregador* para um módulo que
   está sendo importado.

   Desde o Python 3.3, existem dois tipos de localizador:
   *localizadores de metacaminho* para uso com "sys.meta_path", e
   *localizadores de entrada de caminho* para uso com
   "sys.path_hooks".

   Veja **PEP 302**, **PEP 420** e **PEP 451** para mais informações.

divisão pelo piso
   Divisão matemática que arredonda para baixo para o inteiro mais
   próximo. O operador de divisão pelo piso é "//". Por exemplo, a
   expressão "11 // 4" retorna o valor "2" ao invés de "2.75", que
   seria retornado pela divisão de ponto flutuante. Note que "(-11) //
   4" é "-3" porque é "-2.75" arredondado *para baixo*. Consulte a
   **PEP 238**.

função
   Uma série de instruções que retorna algum valor para um chamador.
   Também pode ser passado zero ou mais *argumentos* que podem ser
   usados na execução do corpo. Veja também *parâmetro*, *método* e a
   seção Definições de função.

anotação de função
   Uma *anotação* de um parâmetro de função ou valor de retorno.

   Anotações de função são comumente usados por *dicas de tipo*: por
   exemplo, essa função espera receber dois argumentos "int" e também
   é esperado que devolva um valor "int":

      def sum_two_numbers(a: int, b: int) -> int:
         return a + b

   A sintaxe de anotação de função é explicada na seção Definições de
   função.

   Veja *anotação de variável* e **PEP 484**, que descrevem esta
   funcionalidade. Veja também Boas Práticas de Anotação para as
   melhores práticas sobre como trabalhar com anotações.

__future__
   A instrução future, "from __future__ import <feature>", direciona o
   compilador a compilar o módulo atual usando sintaxe ou semântica
   que será padrão em uma versão futura de Python. O módulo
   "__future__" documenta os possíveis valores de *feature*.
   Importando esse módulo e avaliando suas variáveis, você pode ver
   quando um novo recurso foi inicialmente adicionado à linguagem e
   quando será (ou se já é) o padrão:

      >>> import __future__
      >>> __future__.division
      _Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)

coleta de lixo
   Também conhecido como *garbage collection*, é o processo de liberar
   a memória quando ela não é mais utilizada. Python executa a
   liberação da memória através da contagem de referências e um
   coletor de lixo cíclico que é capaz de detectar e interromper
   referências cíclicas. O coletor de lixo pode ser controlado usando
   o módulo "gc".

gerador
   Uma função que retorna um *iterador gerador*. É parecida com uma
   função normal, exceto pelo fato de conter expressões "yield" para
   produzir uma série de valores que podem ser usados em um laço "for"
   ou que podem ser obtidos um de cada vez com a função "next()".

   Normalmente refere-se a uma função geradora, mas pode referir-se a
   um *iterador gerador* em alguns contextos. Em alguns casos onde o
   significado desejado não está claro, usar o termo completo evita
   ambiguidade.

iterador gerador
   Um objeto criado por uma função *geradora*.

   Cada "yield" suspende temporariamente o processamento, memorizando
   o estado da execução local (incluindo variáveis locais e instruções
   try pendentes). Quando o *iterador gerador* retorna, ele se
   recupera do último ponto onde estava (em contrapartida as funções
   que iniciam uma nova execução a cada vez que são invocadas).

expressão geradora
   Uma expressão que retorna um iterador. Parece uma expressão normal,
   seguido de uma cláusula "for" definindo uma variável de loop, um
   range, e uma cláusula "if" opcional. A expressão combinada gera
   valores para uma função encapsuladora:

      >>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81
      285

função genérica
   Uma função composta por várias funções implementando a mesma
   operação para diferentes tipos. Qual implementação deverá ser usada
   durante a execução é determinada pelo algoritmo de despacho.

   Veja também a entrada *despacho único* no glossário, o decorador
   "functools.singledispatch()", e a **PEP 443**.

tipo genérico
   Um *tipo* que pode ser parametrizado; tipicamente uma classe
   contêiner tal como "list" ou "dict". Usado para *dicas de tipo* e
   *anotações*.

   Para mais detalhes, veja tipo apelido genérico, **PEP 483**, **PEP
   484**, **PEP 585**, e o módulo "typing".

GIL
   Veja *bloqueio global do interpretador*.

bloqueio global do interpretador
   O mecanismo utilizado pelo interpretador *CPython* para garantir
   que apenas uma thread execute o *bytecode* Python por vez. Isto
   simplifica a implementação do CPython ao fazer com que o modelo de
   objetos (incluindo tipos embutidos críticos como o "dict") ganhem
   segurança implícita contra acesso concorrente. Travar todo o
   interpretador facilita que o interpretador em si seja multitarefa,
   às custas de muito do paralelismo já provido por máquinas
   multiprocessador.

   No entanto, alguns módulos de extensão, tanto da biblioteca padrão
   quanto de terceiros, são desenvolvidos de forma a liberar o GIL ao
   realizar tarefas computacionalmente muito intensas, como
   compactação ou cálculos de hash. Além disso, o GIL é sempre
   liberado nas operações de E/S.

   No passado, esforços para criar um interpretador que lidasse
   plenamente com threads (travando dados compartilhados numa
   granularidade bem mais fina) não foram bem sucedidos devido a queda
   no desempenho ao serem executados em processadores de apenas um
   núcleo. Acredita-se que superar essa questão de desempenho acabaria
   tornando a implementação muito mais complicada e bem mais difícil
   de manter.

pyc baseado em hash
   Um arquivo de cache em bytecode que usa hash ao invés do tempo, no
   qual o arquivo de código-fonte foi modificado pela última vez, para
   determinar a sua validade. Veja Cached bytecode invalidation.

hasheável
   Um objeto é *hasheável* se tem um valor de hash que nunca muda
   durante seu ciclo de vida (precisa ter um método "__hash__()") e
   pode ser comparado com outros objetos (precisa ter um método
   "__eq__()"). Objetos hasheáveis que são comparados como iguais
   devem ter o mesmo valor de hash.

   A hasheabilidade faz com que um objeto possa ser usado como uma
   chave de dicionário e como um membro de conjunto, pois estas
   estruturas de dados utilizam os valores de hash internamente.

   A maioria dos objetos embutidos imutáveis do Python são hasheáveis;
   containers mutáveis (tais como listas ou dicionários) não são;
   containers imutáveis (tais como tuplas e frozensets) são hasheáveis
   apenas se os seus elementos são hasheáveis. Objetos que são
   instâncias de classes definidas pelo usuário são hasheáveis por
   padrão. Todos eles comparam de forma desigual (exceto entre si
   mesmos), e o seu valor hash é derivado a partir do seu "id()".

IDLE
   Um ambiente de desenvolvimento e aprendizado integrado para Python.
   IDLE é um editor básico e um ambiente interpretador que vem junto
   com a distribuição padrão do Python.

imutável
   Um objeto que possui um valor fixo. Objetos imutáveis incluem
   números, strings e tuplas. Estes objetos não podem ser alterados.
   Um novo objeto deve ser criado se um valor diferente tiver de ser
   armazenado. Objetos imutáveis têm um papel importante em lugares
   onde um valor constante de hash seja necessário, como por exemplo
   uma chave em um dicionário.

caminho de importação
   Uma lista de localizações (ou *entradas de caminho*) que são
   buscadas pelo *localizador baseado no caminho* por módulos para
   importar. Durante a importação, esta lista de localizações
   usualmente vem a partir de "sys.path", mas para subpacotes ela
   também pode vir do atributo "__path__" de pacotes-pai.

importação
   O processo pelo qual o código Python em um módulo é disponibilizado
   para o código Python em outro módulo.

importador
   Um objeto que localiza e carrega um módulo; Tanto um *localizador*
   e o objeto *carregador*.

interativo
   Python tem um interpretador interativo, o que significa que você
   pode digitar instruções e expressões no prompt do interpretador,
   executá-los imediatamente e ver seus resultados. Apenas execute
   "python" sem argumentos (possivelmente selecionando-o a partir do
   menu de aplicações de seu sistema operacional). O interpretador
   interativo é uma maneira poderosa de testar novas ideias ou
   aprender mais sobre módulos e pacotes (lembre-se do comando
   "help(x)").

interpretado
   Python é uma linguagem interpretada, em oposição àquelas que são
   compiladas, embora esta distinção possa ser nebulosa devido à
   presença do compilador de bytecode. Isto significa que os arquivos-
   fontes podem ser executados diretamente sem necessidade explícita
   de se criar um arquivo executável. Linguagens interpretadas
   normalmente têm um ciclo de desenvolvimento/depuração mais curto
   que as linguagens compiladas, apesar de seus programas geralmente
   serem executados mais lentamente. Veja também *interativo*.

desligamento do interpretador
   Quando solicitado para desligar, o interpretador Python entra em
   uma fase especial, onde ele gradualmente libera todos os recursos
   alocados, tais como módulos e várias estruturas internas críticas.
   Ele também faz diversas chamadas para o *coletor de lixo*. Isto
   pode disparar a execução de código em destrutores definidos pelo
   usuário ou função de retorno de referência fraca. Código executado
   durante a fase de desligamento pode encontrar diversas exceções,
   pois os recursos que ele depende podem não funcionar mais (exemplos
   comuns são os módulos de bibliotecas, ou os mecanismos de avisos).

   A principal razão para o interpretador desligar, é que o módulo
   "__main__" ou o script sendo executado terminou sua execução.

iterável
   Um objeto capaz de retornar seus membros um de cada vez. Exemplos
   de iteráveis incluem todos os tipos de sequência (tais como "list",
   "str" e "tuple") e alguns tipos de não-sequência, como o "dict",
   *objetos arquivos*, além dos objetos de quaisquer classes que você
   definir com um método "__iter__()" ou "__getitem__()" que
   implementam a semântica de *sequência* .

   Iteráveis podem ser usados em um laço "for" e em vários outros
   lugares em que uma sequência é necessária ("zip()", "map()", ...).
   Quando um objeto iterável é passado como argumento para a função
   embutida "iter()", ela retorna um iterador para o objeto. Este
   iterador é adequado para se varrer todo o conjunto de valores. Ao
   usar iteráveis, normalmente não é necessário chamar "iter()" ou
   lidar com os objetos iteradores em si. A instrução "for" faz isso
   automaticamente para você, criando uma variável temporária para
   armazenar o iterador durante a execução do laço. Veja também
   *iterador*, *sequência*, e *gerador*.

iterador
   Um objeto que representa um fluxo de dados. Repetidas chamadas ao
   método "__next__()" de um iterador (ou passando o objeto para a
   função embutida "next()") vão retornar itens sucessivos do fluxo.
   Quando não houver mais dados disponíveis uma exceção
   "StopIteration" será levantada. Neste ponto, o objeto iterador se
   esgotou e quaisquer chamadas subsequentes a seu método "__next__()"
   vão apenas levantar a exceção "StopIteration" novamente. Iteradores
   precisam ter um método "__iter__()" que retorne o objeto iterador
   em si, de forma que todo iterador também é iterável e pode ser
   usado na maioria dos lugares em que um iterável é requerido. Uma
   notável exceção é código que tenta realizar passagens em múltiplas
   iterações. Um objeto contêiner (como uma "list") produz um novo
   iterador a cada vez que você passá-lo para a função "iter()" ou
   utilizá-lo em um laço "for". Tentar isso com o mesmo iterador
   apenas iria retornar o mesmo objeto iterador esgotado já utilizado
   na iteração anterior, como se fosse um contêiner vazio.

   Mais informações podem ser encontradas em Tipos iteradores.

   **Detalhes da implementação do CPython:** O CPython não aplica
   consistentemente o requisito que um iterador define "__iter__()".

função chave
   Uma função chave ou função colação é um chamável que retorna um
   valor usado para ordenação ou classificação. Por exemplo,
   "locale.strxfrm()" é usada para produzir uma chave de ordenação que
   leva o locale em consideração para fins de ordenação.

   Uma porção de ferramentas em Python aceitam funções chave para
   controlar como os elementos são ordenados ou agrupados. Algumas
   delas incluem "min()", "max()", "sorted()", "list.sort()",
   "heapq.merge()", "heapq.nsmallest()", "heapq.nlargest()" e
   "itertools.groupby()".

   Há várias maneiras de se criar funções chave. Por exemplo, o método
   "str.lower()" pode servir como uma função chave para ordenações
   insensíveis à caixa. Alternativamente, uma função chave ad-hoc pode
   ser construída a partir de uma expressão "lambda", como "lambda r:
   (r[0], r[2])". Além disso, "operator.attrgetter()",
   "operator.itemgetter()" e "operator.methodcaller()" são três
   construtores de função chave. Consulte o HowTo de Ordenação para
   ver exemplos de como criar e utilizar funções chave.

argumento nomeado
   Veja *argumento*.

lambda
   Uma função de linha anônima consistindo de uma única *expressão*,
   que é avaliada quando a função é chamada. A sintaxe para criar uma
   função lambda é "lambda [parameters]: expression"

LBYL
   Iniciais da expressão em inglês "look before you leap", que
   significa algo como "olhe antes de pisar". Este estilo de
   codificação testa as pré-condições explicitamente antes de fazer
   chamadas ou buscas. Este estilo contrasta com a abordagem *EAFP* e
   é caracterizada pela presença de muitas instruções "if".

   Em um ambiente multithread, a abordagem LBYL pode arriscar a
   introdução de uma condição de corrida entre "o olhar" e "o pisar".
   Por exemplo, o código "if key in mapping: return mapping[key]" pode
   falhar se outra thread remover *key* do *mapping* após o teste, mas
   antes da olhada. Esse problema pode ser resolvido com bloqueios ou
   usando a abordagem EAFP.

codificação da localidade
   No Unix, é a codificação da localidade do LC_CTYPE, que pode ser
   definida com "locale.setlocale(locale.LC_CTYPE, new_locale)".

   No Windows, é a página de código ANSI (ex: ""cp1252"").

   No Android e no VxWorks, o Python usa ""utf-8"" como a codificação
   da localidade.

   "locale.getencoding()" pode ser usado para obter da codificação da
   localidade.

   Veja também *tratador de erros e codificação do sistema de
   arquivos*.

lista
   Uma *sequência* embutida no Python. Apesar do seu nome, é mais
   próximo de um vetor em outras linguagens do que uma lista
   encadeada, como o acesso aos elementos é da ordem *O*(1).

compreensão de lista
   Uma maneira compacta de processar todos ou parte dos elementos de
   uma sequência e retornar os resultados em uma lista. "result =
   ['{:#04x}'.format(x) for x in range(256) if x % 2 == 0]" gera uma
   lista de strings contendo números hexadecimais (0x..) no intervalo
   de 0 a 255. A cláusula "if" é opcional. Se omitida, todos os
   elementos no "range(256)" serão processados.

carregador
   Um objeto que carrega um módulo. Deve definir um método chamado
   "load_module()". Um carregador é normalmente devolvido por um
   *localizador*. Veja a **PEP 302** para detalhes e
   "importlib.abc.Loader" para um *classe base abstrata*.

método mágico
   Um sinônimo informal para um *método especial*.

mapeamento
   Um objeto contêiner que tem suporte a pesquisas de chave arbitrária
   e implementa os métodos especificados nas "collections.abc.Mapping"
   ou "collections.abc.MutableMapping" classes base abstratas.
   Exemplos incluem "dict", "collections.defaultdict",
   "collections.OrderedDict" e "collections.Counter".

localizador de metacaminho
   Um *localizador* retornado por uma busca de "sys.meta_path".
   Localizadores de metacaminho são relacionados a, mas diferentes de,
   *localizadores de entrada de caminho*.

   Veja "importlib.abc.MetaPathFinder" para os métodos que
   localizadores de metacaminho implementam.

metaclasse
   A classe de uma classe. Definições de classe criam um nome de
   classe, um dicionário de classe e uma lista de classes base. A
   metaclasse é responsável por receber estes três argumentos e criar
   a classe. A maioria das linguagens de programação orientadas a
   objetos provê uma implementação default. O que torna o Python
   especial é o fato de ser possível criar metaclasses personalizadas.
   A maioria dos usuários nunca vai precisar deste recurso, mas quando
   houver necessidade, metaclasses possibilitam soluções poderosas e
   elegantes. Metaclasses têm sido utilizadas para gerar registros de
   acesso a atributos, para incluir proteção contra acesso
   concorrente, rastrear a criação de objetos, implementar singletons,
   dentre muitas outras tarefas.

   Mais informações podem ser encontradas em Metaclasses.

método
   Uma função que é definida dentro do corpo de uma classe. Se chamada
   como um atributo de uma instância daquela classe, o método receberá
   a instância do objeto como seu primeiro *argumento* (que comumente
   é chamado de "self"). Veja *função* e *escopo aninhado*.

ordem de resolução de métodos
   Ordem de resolução de métodos é a ordem em que os membros de uma
   classe base são buscados durante a pesquisa. Veja A ordem de
   resolução de métodos do Python 2.3 para detalhes do algoritmo usado
   pelo interpretador do Python desde a versão 2.3.

módulo
   Um objeto que serve como uma unidade organizacional de código
   Python. Os módulos têm um espaço de nomes contendo objetos Python
   arbitrários. Os módulos são carregados pelo Python através do
   processo de *importação*.

   Veja também *pacote*.

módulo spec
   Um espaço de nomes que contém as informações relacionadas à
   importação usadas para carregar um módulo. Uma instância de
   "importlib.machinery.ModuleSpec".

MRO
   Veja *ordem de resolução de métodos*.

mutável
   Objeto mutável é aquele que pode modificar seus valor mas manter
   seu "id()". Veja também *imutável*.

tupla nomeada
   O termo "tupla nomeada" é aplicado a qualquer tipo ou classe que
   herda de tupla e cujos elementos indexáveis também são acessíveis
   usando atributos nomeados. O tipo ou classe pode ter outras
   funcionalidades também.

   Diversos tipos embutidos são tuplas nomeadas, incluindo os valores
   retornados por "time.localtime()" e "os.stat()". Outro exemplo é
   "sys.float_info":

      >>> sys.float_info[1]                   # indexed access
      1024
      >>> sys.float_info.max_exp              # named field access
      1024
      >>> isinstance(sys.float_info, tuple)   # kind of tuple
      True

   Some named tuples are built-in types (such as the above examples).
   Alternatively, a named tuple can be created from a regular class
   definition that inherits from "tuple" and that defines named
   fields.  Such a class can be written by hand, or it can be created
   by inheriting "typing.NamedTuple", or with the factory function
   "collections.namedtuple()".  The latter techniques also add some
   extra methods that may not be found in hand-written or built-in
   named tuples.

espaço de nomes
   O lugar em que uma variável é armazenada. Espaços de nomes são
   implementados como dicionários. Existem os espaços de nomes local,
   global e nativo, bem como espaços de nomes aninhados em objetos (em
   métodos). Espaços de nomes suportam modularidade ao prevenir
   conflitos de nomes. Por exemplo, as funções "__builtin__.open()" e
   "os.open()" são diferenciadas por seus espaços de nomes. Espaços de
   nomes também auxiliam na legibilidade e na manutenibilidade ao
   torar mais claro quais módulos implementam uma função. Escrever
   "random.seed()" ou "itertools.izip()", por exemplo, deixa claro que
   estas funções são implementadas pelos módulos "random" e
   "itertools" respectivamente.

pacote de espaço de nomes
   Um *pacote* da **PEP 420** que serve apenas como container para sub
   pacotes. Pacotes de espaços de nomes podem não ter representação
   física, e especificamente não são como um *pacote regular* porque
   eles não tem um arquivo "__init__.py".

   Veja também *módulo*.

escopo aninhado
   A habilidade de referir-se a uma variável em uma definição de
   fechamento. Por exemplo, uma função definida dentro de outra pode
   referenciar variáveis da função externa. Perceba que escopos
   aninhados por padrão funcionam apenas por referência e não por
   atribuição. Variáveis locais podem ler e escrever no escopo mais
   interno. De forma similar, variáveis globais podem ler e escrever
   para o espaço de nomes global. O "nonlocal" permite escrita para
   escopos externos.

classe estilo novo
   Antigo nome para o tipo de classes agora usado para todos os
   objetos de classes. Em versões anteriores do Python, apenas classes
   estilo podiam usar recursos novos e versáteis do Python, tais como
   "__slots__", descritores, propriedades, "__getattribute__()",
   métodos de classe, e métodos estáticos.

objeto
   Qualquer dado que tenha estado (atributos ou valores) e
   comportamento definidos (métodos). Também a última classe base de
   qualquer *classe estilo novo*.

pacote
   Um *módulo* Python é capaz de conter submódulos ou recursivamente,
   subpacotes. Tecnicamente, um pacote é um módulo Python com um
   atributo "__path__".

   Veja também *pacote regular* e *pacote de espaço de nomes*.

parâmetro
   Uma entidade nomeada na definição de uma *função* (ou método) que
   específica um *argumento* (ou em alguns casos, argumentos) que a
   função pode receber. Existem cinco tipos de parâmetros:

   * *posicional-ou-nomeado*: especifica um argumento que pode ser
     tanto *posicional* quanto *nomeado*. Esse é o tipo padrão de
     parâmetro, por exemplo *foo* e *bar* a seguir:

        def func(foo, bar=None): ...

   * *somente-posicional*: especifica um argumento que pode ser
     fornecido apenas por posição. Parâmetros somente-posicionais
     podem ser definidos incluindo o caractere "/" na lista de
     parâmetros da definição da função após eles, por exemplo
     *posonly1* e *posonly2* a seguir:

        def func(posonly1, posonly2, /, positional_or_keyword): ...

   * *somente-nomeado*: especifica um argumento que pode ser passado
     para a função somente por nome. Parâmetros somente-nomeados podem
     ser definidos com um simples parâmetro var-posicional ou um "*"
     antes deles na lista de parâmetros na definição da função, por
     exemplo *kw_only1* and *kw_only2* a seguir:

        def func(arg, *, kw_only1, kw_only2): ...

   * *var-posicional*: especifica que uma sequência arbitrária de
     argumentos posicionais pode ser fornecida (em adição a qualquer
     argumento posicional já aceito por outros parâmetros). Tal
     parâmetro pode ser definido colocando um "*" antes do nome do
     parâmetro, por exemplo *args* a seguir:

        def func(*args, **kwargs): ...

   * *var-nomeado*: especifica que, arbitrariamente, muitos argumentos
     nomeados podem ser fornecidos (em adição a qualquer argumento
     nomeado já aceito por outros parâmetros). Tal parâmetro pode
     definido colocando-se "**" antes do nome, por exemplo *kwargs* no
     exemplo acima.

   Parâmetros podem especificar tanto argumentos opcionais quanto
   obrigatórios, assim como valores padrão para alguns argumentos
   opcionais.

   Veja o termo *argumento* no glossário, a pergunta sobre a diferença
   entre argumentos e parâmetros, a classe "inspect.Parameter", a
   seção Definições de função e a **PEP 362**.

entrada de caminho
   Um local único no *caminho de importação* que o *localizador
   baseado no caminho* consulta para encontrar módulos a serem
   importados.

localizador de entrada de caminho
   Um *localizador* retornado por um chamável em "sys.path_hooks" (ou
   seja, um *gancho de entrada de caminho*) que sabe como localizar os
   módulos *entrada de caminho*.

   Veja "importlib.abc.PathEntryFinder" para os métodos que
   localizadores de entrada de caminho implementam.

gancho de entrada de caminho
   Um chamável na lista "sys.path_hooks" que retorna um *localizador
   de entrada de caminho* caso saiba como localizar módulos em uma
   *entrada de caminho* específica.

localizador baseado no caminho
   Um dos *localizadores de metacaminho* que procura por um *caminho
   de importação* de módulos.

objeto caminho ou similar
   Um objeto representando um caminho de sistema de arquivos. Um
   objeto caminho ou similar é ou um objeto "str" ou "bytes"
   representando um caminho, ou um objeto implementando o protocolo
   "os.PathLike". Um objeto que suporta o protocolo "os.PathLike" pode
   ser convertido para um arquivo de caminho do sistema "str" ou
   "bytes", através da chamada da função "os.fspath()";
   "os.fsdecode()" e "os.fsencode()" podem ser usadas para garantir um
   "str" ou "bytes" como resultado, respectivamente. Introduzido na
   **PEP 519**.

PEP
   Proposta de melhoria do Python. Uma PEP é um documento de design
   que fornece informação para a comunidade Python, ou descreve uma
   nova funcionalidade para o Python ou seus predecessores ou
   ambientes. PEPs devem prover uma especificação técnica concisa e um
   racional para funcionalidades propostas.

   PEPs têm a intenção de ser os mecanismos primários para propor
   novas funcionalidades significativas, para coletar opiniões da
   comunidade sobre um problema, e para documentar as decisões de
   design que foram adicionadas ao Python. O autor da PEP é
   responsável por construir um consenso dentro da comunidade e
   documentar opiniões dissidentes.

   Veja **PEP 1**.

porção
   Um conjunto de arquivos em um único diretório (possivelmente
   armazenado em um arquivo zip) que contribuem para um pacote de
   espaço de nomes, conforme definido em **PEP 420**.

argumento posicional
   Veja *argumento*.

API provisória
   Uma API provisória é uma API que foi deliberadamente excluída das
   bibliotecas padrões com compatibilidade retroativa garantida.
   Enquanto mudanças maiores para tais interfaces não são esperadas,
   contanto que elas sejam marcadas como provisórias, mudanças
   retroativas incompatíveis (até e incluindo a remoção da interface)
   podem ocorrer se consideradas necessárias pelos desenvolvedores
   principais. Tais mudanças não serão feitas gratuitamente -- elas
   irão ocorrer apenas se sérias falhas fundamentais forem
   descobertas, que foram esquecidas anteriormente a inclusão da API.

   Mesmo para APIs provisórias, mudanças retroativas incompatíveis são
   vistas como uma "solução em último caso" - cada tentativa ainda
   será feita para encontrar uma resolução retroativa compatível para
   quaisquer problemas encontrados.

   Esse processo permite que a biblioteca padrão continue a evoluir
   com o passar do tempo, sem se prender em erros de design
   problemáticos por períodos de tempo prolongados. Veja **PEP 411**
   para mais detalhes.

pacote provisório
   Veja *API provisória*.

Python 3000
   Apelido para a linha de lançamento da versão do Python 3.x (cunhada
   há muito tempo, quando o lançamento da versão 3 era algo em um
   futuro muito distante.) Esse termo possui a seguinte abreviação:
   "Py3k".

Pythônico
   Uma ideia ou um pedaço de código que segue de perto os idiomas mais
   comuns da linguagem Python, ao invés de implementar códigos usando
   conceitos comuns a outros idiomas. Por exemplo, um idioma comum em
   Python é fazer um loop sobre todos os elementos de uma iterável
   usando a instrução "for". Muitas outras linguagens não têm esse
   tipo de construção, então as pessoas que não estão familiarizadas
   com o Python usam um contador numérico:

      for i in range(len(food)):
          print(food[i])

   Ao contrário do método limpo, ou então, Pythônico:

      for piece in food:
          print(piece)

nome qualificado
   Um nome pontilhado (quando 2 termos são ligados por um ponto) que
   mostra o "path" do escopo global de um módulo para uma classe,
   função ou método definido num determinado módulo, conforme definido
   pela **PEP 3155**. Para funções e classes de nível superior, o nome
   qualificado é o mesmo que o nome do objeto:

      >>> class C:
      ...     class D:
      ...         def meth(self):
      ...             pass
      ...
      >>> C.__qualname__
      'C'
      >>> C.D.__qualname__
      'C.D'
      >>> C.D.meth.__qualname__
      'C.D.meth'

   Quando usado para se referir a módulos, o *nome totalmente
   qualificado* significa todo o caminho pontilhado para o módulo,
   incluindo quaisquer pacotes pai, por exemplo: "email.mime.text":

      >>> import email.mime.text
      >>> email.mime.text.__name__
      'email.mime.text'

contagem de referências
   O número de referências a um objeto. Quando a contagem de
   referências de um objeto cai para zero, ele é desalocado. Alguns
   objetos são "imortais" e têm contagens de referências que nunca são
   modificadas e, portanto, os objetos nunca são desalocados. A
   contagem de referências geralmente não é visível para o código
   Python, mas é um elemento-chave da implementação do *CPython*. Os
   programadores podem chamar a função "sys.getrefcount()" para
   retornar a contagem de referências para um objeto específico.

pacote regular
   Um *pacote* tradicional, como um diretório contendo um arquivo
   "__init__.py".

   Veja também *pacote de espaço de nomes*.

__slots__
   Uma declaração dentro de uma classe que economiza memória
   pré-declarando espaço para atributos de instâncias, e eliminando
   dicionários de instâncias. Apesar de popular, a técnica é um tanto
   quanto complicada de acertar, e é melhor se for reservada para
   casos raros, onde existe uma grande quantidade de instâncias em uma
   aplicação onde a memória é crítica.

sequência
   Um *iterável* com suporte para acesso eficiente a seus elementos
   através de índices inteiros via método especial "__getitem__()" e
   que define o método "__len__()" que devolve o tamanho da sequência.
   Alguns tipos de sequência embutidos são: "list", "str", "tuple", e
   "bytes". Note que "dict" também tem suporte para "__getitem__()" e
   "__len__()", mas é considerado um mapeamento e não uma sequência
   porque a busca usa uma chave *imutável* arbitrária em vez de
   inteiros.

   A classe base abstrata "collections.abc.Sequence" define uma
   interface mais rica que vai além de apenas "__getitem__()" e
   "__len__()", adicionando "count()", "index()", "__contains__()", e
   "__reversed__()". Tipos que implementam essa interface podem ser
   explicitamente registrados usando "register()". Para mais
   documentação sobre métodos de sequências em geral, veja Operações
   comuns de sequências.

compreensão de conjunto
   Uma maneira compacta de processar todos ou parte dos elementos em
   iterável e retornar um conjunto com os resultados. "results = {c
   for c in 'abracadabra' if c not in 'abc'}" gera um conjunto de
   strings "{'r', 'd'}".  Veja Sintaxe de criação de listas, conjuntos
   e dicionários.

despacho único
   Uma forma de despacho de *função genérica* onde a implementação é
   escolhida com base no tipo de um único argumento.

fatia
   Um objeto geralmente contendo uma parte de uma *sequência*. Uma
   fatia é criada usando a notação de subscrito "[]" pode conter
   também até dois pontos entre números, como em
   "variable_name[1:3:5]". A notação de suporte (subscrito) utiliza
   objetos "slice" internamente.

método especial
   Um método que é chamado implicitamente pelo Python para executar
   uma certa operação em um tipo, como uma adição por exemplo. Tais
   métodos tem nomes iniciando e terminando com dois underscores.
   Métodos especiais estão documentados em Nomes de métodos especiais.

instrução
   Uma instrução é parte de uma suíte (um "bloco" de código). Uma
   instrução é ou uma *expressão* ou uma de várias construções com uma
   palavra reservada, tal como "if", "while" ou "for".

verificador de tipo estático
   Uma ferramenta externa que lê o código Python e o analisa,
   procurando por problemas como tipos incorretos. Consulte também
   *dicas de tipo* e o módulo "typing".

referência forte
   Na API C do Python, uma referência forte é uma referência a um
   objeto que pertence ao código que contém a referência. A referência
   forte é obtida chamando "Py_INCREF()" quando a referência é criada
   e liberada com "Py_DECREF()" quando a referência é excluída.

   A função "Py_NewRef()" pode ser usada para criar uma referência
   forte para um objeto. Normalmente, a função "Py_DECREF()" deve ser
   chamada na referência forte antes de sair do escopo da referência
   forte, para evitar o vazamento de uma referência.

   Veja também *referência emprestada*.

codificador de texto
   Uma string em Python é uma sequência de pontos de código Unicode
   (no intervalo "U+0000"--"U+10FFFF"). Para armazenar ou transferir
   uma string, ela precisa ser serializada como uma sequência de
   bytes.

   A serialização de uma string em uma sequência de bytes é conhecida
   como "codificação" e a recriação da string a partir de uma
   sequência de bytes é conhecida como "decodificação".

   Há uma variedade de diferentes serializações de texto codecs, que
   são coletivamente chamadas de "codificações de texto".

arquivo texto
   Um  *objeto arquivo* apto a ler e escrever objetos "str".
   Geralmente, um arquivo texto, na verdade, acessa um fluxo de dados
   de bytes e captura o *codificador de texto* automaticamente.
   Exemplos de arquivos texto são: arquivos abertos em modo texto
   ("'r'" or "'w'"), "sys.stdin", "sys.stdout", e instâncias de
   "io.StringIO".

   Veja também *arquivo binário* para um objeto arquivo apto a ler e
   escrever *objetos byte ou similar*.

aspas triplas
   Uma string que está definida com três ocorrências de aspas duplas
   (") ou apóstrofos ('). Enquanto elas não fornecem nenhuma
   funcionalidade não disponível com strings de aspas simples, elas
   são úteis para inúmeras razões. Elas permitem que você inclua aspas
   simples e duplas não escapadas dentro de uma string, e elas podem
   utilizar múltiplas linhas sem o uso de caractere de continuação,
   fazendo-as especialmente úteis quando escrevemos documentação em
   docstrings.

tipo
   O tipo de um objeto Python determina qual tipo de objeto ele é;
   cada objeto tem um tipo. Um tipo de objeto é acessível pelo
   atributo "__class__" ou pode ser recuperado com "type(obj)".

tipo alias
   Um sinônimo para um tipo, criado através da atribuição do tipo para
   um identificador.

   Tipos alias são úteis para simplificar *dicas de tipo*. Por
   exemplo:

      def remove_gray_shades(
              colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:
          pass

   pode tornar-se mais legível desta forma:

      Color = tuple[int, int, int]

      def remove_gray_shades(colors: list[Color]) -> list[Color]:
          pass

   Veja "typing" e **PEP 484**, a qual descreve esta funcionalidade.

dica de tipo
   Uma *anotação* que especifica o tipo esperado para uma variável, um
   atributo de classe, ou um parâmetro de função ou um valor de
   retorno.

   Dicas de tipo são opcionais e não são forçadas pelo Python, mas
   elas são úteis para *verificadores de tipo estático*. Eles também
   ajudam IDEs a completar e refatorar código.

   Dicas de tipos de variáveis globais, atributos de classes, e
   funções, mas não de variáveis locais, podem ser acessadas usando
   "typing.get_type_hints()".

   Veja "typing" e **PEP 484**, a qual descreve esta funcionalidade.

novas linhas universais
   Uma maneira de interpretar fluxos de textos, na qual todos estes
   são reconhecidos como caracteres de fim de linha: a convenção para
   fim de linha no Unix "'\n'", a convenção no Windows "'\r\n'", e a
   antiga convenção no Macintosh "'\r'". Veja **PEP 278** e **PEP
   3116**, bem como "bytes.splitlines()" para uso adicional.

anotação de variável
   Uma *anotação* de uma variável ou um atributo de classe.

   Ao fazer uma anotação de uma variável ou um atributo de classe, a
   atribuição é opcional:

      class C:
          field: 'annotation'

   Anotações de variáveis são normalmente usadas para *dicas de tipo*:
   por exemplo, espera-se que esta variável receba valores do tipo
   "int":

      count: int = 0

   A sintaxe de anotação de variável é explicada na seção instruções
   de atribuição anotado.

   Veja *anotação de função*, **PEP 484** e **PEP 526**, que descrevem
   esta funcionalidade. Veja também Boas Práticas de Anotação para as
   melhores práticas sobre como trabalhar com anotações.

ambiente virtual
   Um ambiente de execução isolado que permite usuários Python e
   aplicações instalarem e atualizarem pacotes Python sem interferir
   no comportamento de outras aplicações Python em execução no mesmo
   sistema.

   Veja também "venv".

máquina virtual
   Um computador definido inteiramente em software. A máquina virtual
   de Python executa o *bytecode* emitido pelo compilador de bytecode.

Zen do Python
   Lista de princípios de projeto e filosofias do Python que são úteis
   para a compreensão e uso da linguagem. A lista é exibida quando se
   digita ""import this"" no console interativo.
