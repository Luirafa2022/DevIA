Manipulando Exceções
********************

As funções descritas nesse capítulo permitem você tratar e gerar
exceções em Python. É importante entender alguns princípios básicos no
tratamento de exceção no Python. Funciona de forma parecida com a
variável POSIX "errno": existe um indicador global (por thread) do
último erro ocorrido. A maioria das funções da API C não limpa isso
com êxito, mas indica a causa do erro na falha. A maioria das funções
da API retorna um indicador de erro, geralmente, "NULL" se eles devem
retornar um ponteiro, ou "-1" se retornarem um inteiro (exceção: as
funções "PyArg_*" retornam "1" para sucesso e "0" para falha).

Concretamente, o indicador de erro consiste em três ponteiros de
objeto: o tipo da exceção, o valor da exceção e o objeto de traceback.
Qualquer um desses ponteiros pode ser "NULL" se não definido (embora
algumas combinações sejam proibidas, por exemplo, você não pode ter um
retorno não "NULL" se o tipo de exceção for "NULL").

Quando uma função deve falhar porque devido à falha de alguma função
que ela chamou, ela geralmente não define o indicador de erro; a
função que ela chamou já o definiu. Ela é responsável por manipular o
erro e limpar a exceção ou retornar após limpar todos os recursos que
possui (como referências a objetos ou alocações de memória); ela *não*
deve continuar normalmente se não estiver preparada para lidar com o
erro. Se estiver retornando devido a um erro, é importante indicar ao
chamador que um erro foi definido. Se o erro não for manipulado ou
propagado com cuidado, chamadas adicionais para a API Python/C podem
não se comportar conforme o esperado e podem falhar de maneiras
misteriosas.

Nota:

  O indicador de erro **not** é resultado de "sys.exc_info()".  O
  primeiro corresponde a uma exceção que ainda não foi capturada (e,
  portanto, ainda está se propagando), enquanto o segundo retorna uma
  exceção após ser capturada (e, portanto, parou de se propagar).


Impressão e limpeza
===================

void PyErr_Clear()
    * Parte da ABI Estável.*

   Limpe o indicador de erro. Se o indicador de erro não estiver
   definido, não haverá efeito.

void PyErr_PrintEx(int set_sys_last_vars)
    * Parte da ABI Estável.*

   Print a standard traceback to "sys.stderr" and clear the error
   indicator. **Unless** the error is a "SystemExit", in that case no
   traceback is printed and the Python process will exit with the
   error code specified by the "SystemExit" instance.

   Chame esta função **apenas** quando o indicador de erro estiver
   definido. Caso contrário, causará um erro fatal!

   If *set_sys_last_vars* is nonzero, the variable "sys.last_exc" is
   set to the printed exception. For backwards compatibility, the
   deprecated variables "sys.last_type", "sys.last_value" and
   "sys.last_traceback" are also set to the type, value and traceback
   of this exception, respectively.

   Alterado na versão 3.12: The setting of "sys.last_exc" was added.

void PyErr_Print()
    * Parte da ABI Estável.*

   Apelido para "PyErr_PrintEx(1)".

void PyErr_WriteUnraisable(PyObject *obj)
    * Parte da ABI Estável.*

   Chama "sys.unraisablehook()" usando a exceção atual e o argumento
   *obj*.

   This utility function prints a warning message to "sys.stderr" when
   an exception has been set but it is impossible for the interpreter
   to actually raise the exception.  It is used, for example, when an
   exception occurs in an "__del__()" method.

   The function is called with a single argument *obj* that identifies
   the context in which the unraisable exception occurred. If
   possible, the repr of *obj* will be printed in the warning message.
   If *obj* is "NULL", only the traceback is printed.

   Uma exceção deve ser definida ao chamar essa função.

   Alterado na versão 3.4: Exibe o traceback (situação da pilha de
   execução). Exibe apenas o traceback se *obj* for "NULL".

   Alterado na versão 3.8: Utiliza "sys.unraisablehook()".

void PyErr_DisplayException(PyObject *exc)
    * Parte da ABI Estável desde a versão 3.12.*

   Print the standard traceback display of "exc" to "sys.stderr",
   including chained exceptions and notes.

   Novo na versão 3.12.


Lançando exceções
=================

Essas funções ajudam a definir o indicador de erro do thread. Por
conveniência, algumas dessas funções sempre retornam um ponteiro
"NULL" ao usar instrução com "return".

void PyErr_SetString(PyObject *type, const char *message)
    * Parte da ABI Estável.*

   This is the most common way to set the error indicator.  The first
   argument specifies the exception type; it is normally one of the
   standard exceptions, e.g. "PyExc_RuntimeError".  You need not
   create a new *strong reference* to it (e.g. with "Py_INCREF()").
   The second argument is an error message; it is decoded from
   "'utf-8'".

void PyErr_SetObject(PyObject *type, PyObject *value)
    * Parte da ABI Estável.*

   Essa função é semelhante à "PyErr_SetString()" mas permite
   especificar um objeto Python arbitrário para o valor da exceção.

PyObject *PyErr_Format(PyObject *exception, const char *format, ...)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável.*

   This function sets the error indicator and returns "NULL".
   *exception* should be a Python exception class.  The *format* and
   subsequent parameters help format the error message; they have the
   same meaning and values as in "PyUnicode_FromFormat()". *format* is
   an ASCII-encoded string.

PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável desde a versão
   3.5.*

   Igual a "PyErr_Format()", mas usando o argumento "va_list" em vez
   de um número variável de argumentos.

   Novo na versão 3.5.

void PyErr_SetNone(PyObject *type)
    * Parte da ABI Estável.*

   Isso é uma abreviação para "PyErr_SetObject(type, Py_None)".

int PyErr_BadArgument()
    * Parte da ABI Estável.*

   This is a shorthand for "PyErr_SetString(PyExc_TypeError,
   message)", where *message* indicates that a built-in operation was
   invoked with an illegal argument.  It is mostly for internal use.

PyObject *PyErr_NoMemory()
    *Retorna valor: Sempre NULL.** Parte da ABI Estável.*

   Essa é uma abreviação para "PyErr_SetNone(PyExc_MemoryError)"; que
   retorna "NULL"  para que uma função de alocação de objeto possa
   escrever "return PyErr_NoMemory();"  quando ficar sem memória.

PyObject *PyErr_SetFromErrno(PyObject *type)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável.*

   This is a convenience function to raise an exception when a C
   library function has returned an error and set the C variable
   "errno".  It constructs a tuple object whose first item is the
   integer "errno" value and whose second item is the corresponding
   error message (gotten from "strerror()"), and then calls
   "PyErr_SetObject(type, object)".  On Unix, when the "errno" value
   is "EINTR", indicating an interrupted system call, this calls
   "PyErr_CheckSignals()", and if that set the error indicator, leaves
   it set to that.  The function always returns "NULL", so a wrapper
   function around a system call can write "return
   PyErr_SetFromErrno(type);" when the system call returns an error.

PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *type, PyObject *filenameObject)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável.*

   Similar to "PyErr_SetFromErrno()", with the additional behavior
   that if *filenameObject* is not "NULL", it is passed to the
   constructor of *type* as a third parameter.  In the case of
   "OSError" exception, this is used to define the "filename"
   attribute of the exception instance.

PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *type, PyObject *filenameObject, PyObject *filenameObject2)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável desde a versão
   3.7.*

   Similar to "PyErr_SetFromErrnoWithFilenameObject()", but takes a
   second filename object, for raising errors when a function that
   takes two filenames fails.

   Novo na versão 3.4.

PyObject *PyErr_SetFromErrnoWithFilename(PyObject *type, const char *filename)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável.*

   Similar to "PyErr_SetFromErrnoWithFilenameObject()", but the
   filename is given as a C string.  *filename* is decoded from the
   *filesystem encoding and error handler*.

PyObject *PyErr_SetFromWindowsErr(int ierr)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável on Windows
   desde a versão 3.7.*

   This is a convenience function to raise "WindowsError". If called
   with *ierr* of "0", the error code returned by a call to
   "GetLastError()" is used instead.  It calls the Win32 function
   "FormatMessage()" to retrieve the Windows description of error code
   given by *ierr* or "GetLastError()", then it constructs a tuple
   object whose first item is the *ierr* value and whose second item
   is the corresponding error message (gotten from "FormatMessage()"),
   and then calls "PyErr_SetObject(PyExc_WindowsError, object)". This
   function always returns "NULL".

   Disponibilidade: Windows.

PyObject *PyErr_SetExcFromWindowsErr(PyObject *type, int ierr)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável on Windows
   desde a versão 3.7.*

   Similar to "PyErr_SetFromWindowsErr()", with an additional
   parameter specifying the exception type to be raised.

   Disponibilidade: Windows.

PyObject *PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável on Windows
   desde a versão 3.7.*

   Similar to "PyErr_SetFromWindowsErr()", with the additional
   behavior that if *filename* is not "NULL", it is decoded from the
   filesystem encoding ("os.fsdecode()") and passed to the constructor
   of "OSError" as a third parameter to be used to define the
   "filename" attribute of the exception instance.

   Disponibilidade: Windows.

PyObject *PyErr_SetExcFromWindowsErrWithFilenameObject(PyObject *type, int ierr, PyObject *filename)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável on Windows
   desde a versão 3.7.*

   Similar to "PyErr_SetExcFromWindowsErr()", with the additional
   behavior that if *filename* is not "NULL", it is passed to the
   constructor of "OSError" as a third parameter to be used to define
   the "filename" attribute of the exception instance.

   Disponibilidade: Windows.

PyObject *PyErr_SetExcFromWindowsErrWithFilenameObjects(PyObject *type, int ierr, PyObject *filename, PyObject *filename2)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável on Windows
   desde a versão 3.7.*

   Similar à "PyErr_SetExcFromWindowsErrWithFilenameObject()", mas
   aceita um segundo caminho do objeto.

   Disponibilidade: Windows.

   Novo na versão 3.4.

PyObject *PyErr_SetExcFromWindowsErrWithFilename(PyObject *type, int ierr, const char *filename)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável on Windows
   desde a versão 3.7.*

   Similar à "PyErr_SetFromWindowsErrWithFilename()", com um parâmetro
   adicional especificando o tipo de exceção a ser gerado.

   Disponibilidade: Windows.

PyObject *PyErr_SetImportError(PyObject *msg, PyObject *name, PyObject *path)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável desde a versão
   3.7.*

   This is a convenience function to raise "ImportError". *msg* will
   be set as the exception's message string. *name* and *path*, both
   of which can be "NULL", will be set as the "ImportError"'s
   respective "name" and "path" attributes.

   Novo na versão 3.3.

PyObject *PyErr_SetImportErrorSubclass(PyObject *exception, PyObject *msg, PyObject *name, PyObject *path)
    *Retorna valor: Sempre NULL.** Parte da ABI Estável desde a versão
   3.6.*

   Muito parecido com "PyErr_SetImportError()" mas a função permite
   especificar uma subclasse de "ImportError" para levantar uma
   exceção.

   Novo na versão 3.6.

void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)

   Set file, line, and offset information for the current exception.
   If the current exception is not a "SyntaxError", then it sets
   additional attributes, which make the exception printing subsystem
   think the exception is a "SyntaxError".

   Novo na versão 3.4.

void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
    * Parte da ABI Estável desde a versão 3.7.*

   Like "PyErr_SyntaxLocationObject()", but *filename* is a byte
   string decoded from the *filesystem encoding and error handler*.

   Novo na versão 3.2.

void PyErr_SyntaxLocation(const char *filename, int lineno)
    * Parte da ABI Estável.*

   Like "PyErr_SyntaxLocationEx()", but the *col_offset* parameter is
   omitted.

void PyErr_BadInternalCall()
    * Parte da ABI Estável.*

   This is a shorthand for "PyErr_SetString(PyExc_SystemError,
   message)", where *message* indicates that an internal operation
   (e.g. a Python/C API function) was invoked with an illegal
   argument.  It is mostly for internal use.


Emitindo advertências
=====================

Use these functions to issue warnings from C code.  They mirror
similar functions exported by the Python "warnings" module.  They
normally print a warning message to *sys.stderr*; however, it is also
possible that the user has specified that warnings are to be turned
into errors, and in that case they will raise an exception.  It is
also possible that the functions raise an exception because of a
problem with the warning machinery. The return value is "0" if no
exception is raised, or "-1" if an exception is raised.  (It is not
possible to determine whether a warning message is actually printed,
nor what the reason is for the exception; this is intentional.)  If an
exception is raised, the caller should do its normal exception
handling (for example, "Py_DECREF()" owned references and return an
error value).

int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
    * Parte da ABI Estável.*

   Issue a warning message.  The *category* argument is a warning
   category (see below) or "NULL"; the *message* argument is a UTF-8
   encoded string.  *stack_level* is a positive number giving a number
   of stack frames; the warning will be issued from the  currently
   executing line of code in that stack frame.  A *stack_level* of 1
   is the function calling "PyErr_WarnEx()", 2 is  the function above
   that, and so forth.

   Warning categories must be subclasses of "PyExc_Warning";
   "PyExc_Warning" is a subclass of "PyExc_Exception"; the default
   warning category is "PyExc_RuntimeWarning". The standard Python
   warning categories are available as global variables whose names
   are enumerated at Categorias de aviso padrão.

   For information about warning control, see the documentation for
   the "warnings" module and the "-W" option in the command line
   documentation.  There is no C API for warning control.

int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)

   Issue a warning message with explicit control over all warning
   attributes.  This is a straightforward wrapper around the Python
   function "warnings.warn_explicit()"; see there for more
   information.  The *module* and *registry* arguments may be set to
   "NULL" to get the default effect described there.

   Novo na versão 3.4.

int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
    * Parte da ABI Estável.*

   Similar to "PyErr_WarnExplicitObject()" except that *message* and
   *module* are UTF-8 encoded strings, and *filename* is decoded from
   the *filesystem encoding and error handler*.

int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
    * Parte da ABI Estável.*

   Function similar to "PyErr_WarnEx()", but use
   "PyUnicode_FromFormat()" to format the warning message.  *format*
   is an ASCII-encoded string.

   Novo na versão 3.2.

int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
    * Parte da ABI Estável desde a versão 3.6.*

   Function similar to "PyErr_WarnFormat()", but *category* is
   "ResourceWarning" and it passes *source* to
   "warnings.WarningMessage".

   Novo na versão 3.6.


Consultando o indicador de erro
===============================

PyObject *PyErr_Occurred()
    *Retorna valor: Referência emprestada.** Parte da ABI Estável.*

   Test whether the error indicator is set.  If set, return the
   exception *type* (the first argument to the last call to one of the
   "PyErr_Set*" functions or to "PyErr_Restore()").  If not set,
   return "NULL".  You do not own a reference to the return value, so
   you do not need to "Py_DECREF()" it.

   The caller must hold the GIL.

   Nota:

     Do not compare the return value to a specific exception; use
     "PyErr_ExceptionMatches()" instead, shown below.  (The comparison
     could easily fail since the exception may be an instance instead
     of a class, in the case of a class exception, or it may be a
     subclass of the expected exception.)

int PyErr_ExceptionMatches(PyObject *exc)
    * Parte da ABI Estável.*

   Equivalent to "PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)".
   This should only be called when an exception is actually set; a
   memory access violation will occur if no exception has been raised.

int PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)
    * Parte da ABI Estável.*

   Return true if the *given* exception matches the exception type in
   *exc*.  If *exc* is a class object, this also returns true when
   *given* is an instance of a subclass.  If *exc* is a tuple, all
   exception types in the tuple (and recursively in subtuples) are
   searched for a match.

PyObject *PyErr_GetRaisedException(void)
    *Retorna valor: Nova referência.** Parte da ABI Estável desde a
   versão 3.12.*

   Return the exception currently being raised, clearing the error
   indicator at the same time. Return "NULL" if the error indicator is
   not set.

   This function is used by code that needs to catch exceptions, or
   code that needs to save and restore the error indicator
   temporarily.

   Por exemplo:

      {
         PyObject *exc = PyErr_GetRaisedException();

         /* ... code that might produce other errors ... */

         PyErr_SetRaisedException(exc);
      }

   Ver também:

     "PyErr_GetHandledException()", to save the exception currently
     being handled.

   Novo na versão 3.12.

void PyErr_SetRaisedException(PyObject *exc)
    * Parte da ABI Estável desde a versão 3.12.*

   Set *exc* as the exception currently being raised, clearing the
   existing exception if one is set.

   Aviso:

     This call steals a reference to *exc*, which must be a valid
     exception.

   Novo na versão 3.12.

void PyErr_Fetch(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)
    * Parte da ABI Estável.*

   Obsoleto desde a versão 3.12: Use "PyErr_GetRaisedException()"
   instead.

   Retrieve the error indicator into three variables whose addresses
   are passed. If the error indicator is not set, set all three
   variables to "NULL".  If it is set, it will be cleared and you own
   a reference to each object retrieved.  The value and traceback
   object may be "NULL" even when the type object is not.

   Nota:

     This function is normally only used by legacy code that needs to
     catch exceptions or save and restore the error indicator
     temporarily.Por exemplo:

        {
           PyObject *type, *value, *traceback;
           PyErr_Fetch(&type, &value, &traceback);

           /* ... code that might produce other errors ... */

           PyErr_Restore(type, value, traceback);
        }

void PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)
    * Parte da ABI Estável.*

   Obsoleto desde a versão 3.12: Use "PyErr_SetRaisedException()"
   instead.

   Set the error indicator from the three objects, *type*, *value*,
   and *traceback*, clearing the existing exception if one is set. If
   the objects are "NULL", the error indicator is cleared.  Do not
   pass a "NULL" type and non-"NULL" value or traceback.  The
   exception type should be a class.  Do not pass an invalid exception
   type or value. (Violating these rules will cause subtle problems
   later.)  This call takes away a reference to each object: you must
   own a reference to each object before the call and after the call
   you no longer own these references.  (If you don't understand this,
   don't use this function.  I warned you.)

   Nota:

     This function is normally only used by legacy code that needs to
     save and restore the error indicator temporarily. Use
     "PyErr_Fetch()" to save the current error indicator.

void PyErr_NormalizeException(PyObject **exc, PyObject **val, PyObject **tb)
    * Parte da ABI Estável.*

   Obsoleto desde a versão 3.12: Use "PyErr_GetRaisedException()"
   instead, to avoid any possible de-normalization.

   Under certain circumstances, the values returned by "PyErr_Fetch()"
   below can be "unnormalized", meaning that "*exc" is a class object
   but "*val" is not an instance of the  same class.  This function
   can be used to instantiate the class in that case.  If the values
   are already normalized, nothing happens. The delayed normalization
   is implemented to improve performance.

   Nota:

     This function *does not* implicitly set the "__traceback__"
     attribute on the exception value. If setting the traceback
     appropriately is desired, the following additional snippet is
     needed:

        if (tb != NULL) {
          PyException_SetTraceback(val, tb);
        }

PyObject *PyErr_GetHandledException(void)
    * Parte da ABI Estável desde a versão 3.11.*

   Retrieve the active exception instance, as would be returned by
   "sys.exception()". This refers to an exception that was *already
   caught*, not to an exception that was freshly raised. Returns a new
   reference to the exception or "NULL". Does not modify the
   interpreter's exception state.

   Nota:

     This function is not normally used by code that wants to handle
     exceptions. Rather, it can be used when code needs to save and
     restore the exception state temporarily.  Use
     "PyErr_SetHandledException()" to restore or clear the exception
     state.

   Novo na versão 3.11.

void PyErr_SetHandledException(PyObject *exc)
    * Parte da ABI Estável desde a versão 3.11.*

   Set the active exception, as known from "sys.exception()".  This
   refers to an exception that was *already caught*, not to an
   exception that was freshly raised. To clear the exception state,
   pass "NULL".

   Nota:

     This function is not normally used by code that wants to handle
     exceptions. Rather, it can be used when code needs to save and
     restore the exception state temporarily.  Use
     "PyErr_GetHandledException()" to get the exception state.

   Novo na versão 3.11.

void PyErr_GetExcInfo(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)
    * Parte da ABI Estável desde a versão 3.7.*

   Retrieve the old-style representation of the exception info, as
   known from "sys.exc_info()".  This refers to an exception that was
   *already caught*, not to an exception that was freshly raised.
   Returns new references for the three objects, any of which may be
   "NULL".  Does not modify the exception info state.  This function
   is kept for backwards compatibility. Prefer using
   "PyErr_GetHandledException()".

   Nota:

     This function is not normally used by code that wants to handle
     exceptions. Rather, it can be used when code needs to save and
     restore the exception state temporarily.  Use
     "PyErr_SetExcInfo()" to restore or clear the exception state.

   Novo na versão 3.3.

void PyErr_SetExcInfo(PyObject *type, PyObject *value, PyObject *traceback)
    * Parte da ABI Estável desde a versão 3.7.*

   Set the exception info, as known from "sys.exc_info()".  This
   refers to an exception that was *already caught*, not to an
   exception that was freshly raised.  This function steals the
   references of the arguments. To clear the exception state, pass
   "NULL" for all three arguments. This function is kept for backwards
   compatibility. Prefer using "PyErr_SetHandledException()".

   Nota:

     This function is not normally used by code that wants to handle
     exceptions. Rather, it can be used when code needs to save and
     restore the exception state temporarily.  Use
     "PyErr_GetExcInfo()" to read the exception state.

   Novo na versão 3.3.

   Alterado na versão 3.11: The "type" and "traceback" arguments are
   no longer used and can be NULL. The interpreter now derives them
   from the exception instance (the "value" argument). The function
   still steals references of all three arguments.


Tratamento de sinal
===================

int PyErr_CheckSignals()
    * Parte da ABI Estável.*

   Essa função interage com o manipulador de sinais do Python.

   If the function is called from the main thread and under the main
   Python interpreter, it checks whether a signal has been sent to the
   processes and if so, invokes the corresponding signal handler.  If
   the "signal" module is supported, this can invoke a signal handler
   written in Python.

   The function attempts to handle all pending signals, and then
   returns "0". However, if a Python signal handler raises an
   exception, the error indicator is set and the function returns "-1"
   immediately (such that other pending signals may not have been
   handled yet: they will be on the next "PyErr_CheckSignals()"
   invocation).

   If the function is called from a non-main thread, or under a non-
   main Python interpreter, it does nothing and returns "0".

   This function can be called by long-running C code that wants to be
   interruptible by user requests (such as by pressing Ctrl-C).

   Nota:

     The default Python signal handler for "SIGINT" raises the
     "KeyboardInterrupt" exception.

void PyErr_SetInterrupt()
    * Parte da ABI Estável.*

   Simulate the effect of a "SIGINT" signal arriving. This is
   equivalent to "PyErr_SetInterruptEx(SIGINT)".

   Nota:

     This function is async-signal-safe.  It can be called without the
     *GIL* and from a C signal handler.

int PyErr_SetInterruptEx(int signum)
    * Parte da ABI Estável desde a versão 3.10.*

   Simulate the effect of a signal arriving. The next time
   "PyErr_CheckSignals()" is called,  the Python signal handler for
   the given signal number will be called.

   This function can be called by C code that sets up its own signal
   handling and wants Python signal handlers to be invoked as expected
   when an interruption is requested (for example when the user
   presses Ctrl-C to interrupt an operation).

   If the given signal isn't handled by Python (it was set to
   "signal.SIG_DFL" or "signal.SIG_IGN"), it will be ignored.

   If *signum* is outside of the allowed range of signal numbers, "-1"
   is returned.  Otherwise, "0" is returned.  The error indicator is
   never changed by this function.

   Nota:

     This function is async-signal-safe.  It can be called without the
     *GIL* and from a C signal handler.

   Novo na versão 3.10.

int PySignal_SetWakeupFd(int fd)

   This utility function specifies a file descriptor to which the
   signal number is written as a single byte whenever a signal is
   received. *fd* must be non-blocking. It returns the previous such
   file descriptor.

   O valor "-1" desabilita o recurso; este é o estado inicial. Isso é
   equivalente à "signal.set_wakeup_fd()" em Python, mas sem nenhuma
   verificação de erro. *fd* deve ser um descritor de arquivo válido.
   A função só deve ser chamada a partir da thread principal.

   Alterado na versão 3.5: No Windows, a função agora também suporta
   manipuladores de socket.


Classes de exceção
==================

PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   This utility function creates and returns a new exception class.
   The *name* argument must be the name of the new exception, a C
   string of the form "module.classname".  The *base* and *dict*
   arguments are normally "NULL". This creates a class object derived
   from "Exception" (accessible in C as "PyExc_Exception").

   The "__module__" attribute of the new class is set to the first
   part (up to the last dot) of the *name* argument, and the class
   name is set to the last part (after the last dot).  The *base*
   argument can be used to specify alternate base classes; it can
   either be only one class or a tuple of classes. The *dict* argument
   can be used to specify a dictionary of class variables and methods.

PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Same as "PyErr_NewException()", except that the new exception class
   can easily be given a docstring: If *doc* is non-"NULL", it will be
   used as the docstring for the exception class.

   Novo na versão 3.2.


Objeto Exceção
==============

PyObject *PyException_GetTraceback(PyObject *ex)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Return the traceback associated with the exception as a new
   reference, as accessible from Python through the "__traceback__"
   attribute. If there is no traceback associated, this returns
   "NULL".

int PyException_SetTraceback(PyObject *ex, PyObject *tb)
    * Parte da ABI Estável.*

   Defina o retorno traceback (situação da pilha de execução)
   associado à exceção como *tb*. Use "Py_None" para limpá-lo.

PyObject *PyException_GetContext(PyObject *ex)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Return the context (another exception instance during whose
   handling *ex* was raised) associated with the exception as a new
   reference, as accessible from Python through the "__context__"
   attribute. If there is no context associated, this returns "NULL".

void PyException_SetContext(PyObject *ex, PyObject *ctx)
    * Parte da ABI Estável.*

   Set the context associated with the exception to *ctx*.  Use "NULL"
   to clear it.  There is no type check to make sure that *ctx* is an
   exception instance. This steals a reference to *ctx*.

PyObject *PyException_GetCause(PyObject *ex)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Return the cause (either an exception instance, or "None", set by
   "raise ... from ...") associated with the exception as a new
   reference, as accessible from Python through the "__cause__"
   attribute.

void PyException_SetCause(PyObject *ex, PyObject *cause)
    * Parte da ABI Estável.*

   Set the cause associated with the exception to *cause*.  Use "NULL"
   to clear it.  There is no type check to make sure that *cause* is
   either an exception instance or "None".  This steals a reference to
   *cause*.

   The "__suppress_context__" attribute is implicitly set to "True" by
   this function.

PyObject *PyException_GetArgs(PyObject *ex)
    *Retorna valor: Nova referência.** Parte da ABI Estável desde a
   versão 3.12.*

   Return "args" of exception *ex*.

void PyException_SetArgs(PyObject *ex, PyObject *args)
    * Parte da ABI Estável desde a versão 3.12.*

   Set "args" of exception *ex* to *args*.

PyObject *PyUnstable_Exc_PrepReraiseStar(PyObject *orig, PyObject *excs)

   *Esta é uma API Instável. Isso pode se alterado sem aviso em
   lançamentos menores.*

   Implement part of the interpreter's implementation of "except*".
   *orig* is the original exception that was caught, and *excs* is the
   list of the exceptions that need to be raised. This list contains
   the unhandled part of *orig*, if any, as well as the exceptions
   that were raised from the "except*" clauses (so they have a
   different traceback from *orig*) and those that were reraised (and
   have the same traceback as *orig*). Return the "ExceptionGroup"
   that needs to be reraised in the end, or "None" if there is nothing
   to reraise.

   Novo na versão 3.12.


Objetos de exceção Unicode
==========================

As seguintes funções são usadas para criar e modificar exceções
Unicode de C.

PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Create a "UnicodeDecodeError" object with the attributes
   *encoding*, *object*, *length*, *start*, *end* and *reason*.
   *encoding* and *reason* are UTF-8 encoded strings.

PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *exc)
PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *exc)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Retorna o atributo * encoding* dado no objeto da exceção.

PyObject *PyUnicodeDecodeError_GetObject(PyObject *exc)
PyObject *PyUnicodeEncodeError_GetObject(PyObject *exc)
PyObject *PyUnicodeTranslateError_GetObject(PyObject *exc)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Retorna o atributo *object* dado no objeto da exceção.

int PyUnicodeDecodeError_GetStart(PyObject *exc, Py_ssize_t *start)
int PyUnicodeEncodeError_GetStart(PyObject *exc, Py_ssize_t *start)
int PyUnicodeTranslateError_GetStart(PyObject *exc, Py_ssize_t *start)
    * Parte da ABI Estável.*

   Obtém o atributo *start* do objeto da exceção coloca-o em **start*.
   *start* não deve ser "NULL". Retorna "0" se não der erro, "-1" caso
   dê erro.

int PyUnicodeDecodeError_SetStart(PyObject *exc, Py_ssize_t start)
int PyUnicodeEncodeError_SetStart(PyObject *exc, Py_ssize_t start)
int PyUnicodeTranslateError_SetStart(PyObject *exc, Py_ssize_t start)
    * Parte da ABI Estável.*

   Define o atributo *start* dado no objeto de exceção *start*. Em
   caso de sucesso, retorna "0", em caso de falha, retorna "-1".

int PyUnicodeDecodeError_GetEnd(PyObject *exc, Py_ssize_t *end)
int PyUnicodeEncodeError_GetEnd(PyObject *exc, Py_ssize_t *end)
int PyUnicodeTranslateError_GetEnd(PyObject *exc, Py_ssize_t *end)
    * Parte da ABI Estável.*

   Obtenha o atributo *end* dado no objeto de exceção e coloque
   **end*. O *end* não deve ser "NULL". Em caso de sucesso, retorna
   "0", em caso de falha, retorna "-1".

int PyUnicodeDecodeError_SetEnd(PyObject *exc, Py_ssize_t end)
int PyUnicodeEncodeError_SetEnd(PyObject *exc, Py_ssize_t end)
int PyUnicodeTranslateError_SetEnd(PyObject *exc, Py_ssize_t end)
    * Parte da ABI Estável.*

   Set the *end* attribute of the given exception object to *end*.
   Return "0" on success, "-1" on failure.

PyObject *PyUnicodeDecodeError_GetReason(PyObject *exc)
PyObject *PyUnicodeEncodeError_GetReason(PyObject *exc)
PyObject *PyUnicodeTranslateError_GetReason(PyObject *exc)
    *Retorna valor: Nova referência.** Parte da ABI Estável.*

   Retorna o atributo *reason* dado no objeto da exceção.

int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
    * Parte da ABI Estável.*

   Set the *reason* attribute of the given exception object to
   *reason*.  Return "0" on success, "-1" on failure.


Controle de recursão
====================

These two functions provide a way to perform safe recursive calls at
the C level, both in the core and in extension modules.  They are
needed if the recursive code does not necessarily invoke Python code
(which tracks its recursion depth automatically). They are also not
needed for *tp_call* implementations because the call protocol takes
care of recursion handling.

int Py_EnterRecursiveCall(const char *where)
    * Parte da ABI Estável desde a versão 3.9.*

   Marca um ponto em que a chamada recursiva em nível C está prestes a
   ser executada.

   If "USE_STACKCHECK" is defined, this function checks if the OS
   stack overflowed using "PyOS_CheckStack()".  If this is the case,
   it sets a "MemoryError" and returns a nonzero value.

   The function then checks if the recursion limit is reached.  If
   this is the case, a "RecursionError" is set and a nonzero value is
   returned. Otherwise, zero is returned.

   *where* should be a UTF-8 encoded string such as "" in instance
   check"" to be concatenated to the "RecursionError" message caused
   by the recursion depth limit.

   Alterado na versão 3.9: This function is now also available in the
   limited API.

void Py_LeaveRecursiveCall(void)
    * Parte da ABI Estável desde a versão 3.9.*

   Ends a "Py_EnterRecursiveCall()".  Must be called once for each
   *successful* invocation of "Py_EnterRecursiveCall()".

   Alterado na versão 3.9: This function is now also available in the
   limited API.

Properly implementing "tp_repr" for container types requires special
recursion handling.  In addition to protecting the stack, "tp_repr"
also needs to track objects to prevent cycles.  The following two
functions facilitate this functionality.  Effectively, these are the C
equivalent to "reprlib.recursive_repr()".

int Py_ReprEnter(PyObject *object)
    * Parte da ABI Estável.*

   Chamado no início da implementação "tp_repr" para detectar ciclos.

   If the object has already been processed, the function returns a
   positive integer.  In that case the "tp_repr" implementation should
   return a string object indicating a cycle.  As examples, "dict"
   objects return "{...}" and "list" objects return "[...]".

   A função retornará um inteiro negativo se o limite da recursão for
   atingido. Nesse caso a implementação "tp_repr" deverá,
   normalmente,. retornar "NULL".

   Caso contrário, a função retorna zero e a implementação "tp_repr"
   poderá continuar normalmente.

void Py_ReprLeave(PyObject *object)
    * Parte da ABI Estável.*

   Termina a "Py_ReprEnter()". Deve ser chamado uma vez para cada
   chamada de "Py_ReprEnter()" que retorna zero.


Exceções Padrão
===============

All standard Python exceptions are available as global variables whose
names are "PyExc_" followed by the Python exception name.  These have
the type PyObject*; they are all class objects.  For completeness,
here are all the variables:

+-------------------------------------------+-----------------------------------+------------+
| Nome C                                    | Nome Python                       | Notas      |
|===========================================|===================================|============|
| "PyExc_BaseException"                     | "BaseException"                   | [1]        |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_Exception"                         | "Exception"                       | [1]        |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ArithmeticError"                   | "ArithmeticError"                 | [1]        |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_AssertionError"                    | "AssertionError"                  |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_AttributeError"                    | "AttributeError"                  |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_BlockingIOError"                   | "BlockingIOError"                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_BrokenPipeError"                   | "BrokenPipeError"                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_BufferError"                       | "BufferError"                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ChildProcessError"                 | "ChildProcessError"               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionAbortedError"            | "ConnectionAbortedError"          |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionError"                   | "ConnectionError"                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionRefusedError"            | "ConnectionRefusedError"          |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ConnectionResetError"              | "ConnectionResetError"            |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_EOFError"                          | "EOFError"                        |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_FileExistsError"                   | "FileExistsError"                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_FileNotFoundError"                 | "FileNotFoundError"               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_FloatingPointError"                | "FloatingPointError"              |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_GeneratorExit"                     | "GeneratorExit"                   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ImportError"                       | "ImportError"                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_IndentationError"                  | "IndentationError"                |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_IndexError"                        | "IndexError"                      |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_InterruptedError"                  | "InterruptedError"                |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_IsADirectoryError"                 | "IsADirectoryError"               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_KeyError"                          | "KeyError"                        |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_KeyboardInterrupt"                 | "KeyboardInterrupt"               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_LookupError"                       | "LookupError"                     | [1]        |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_MemoryError"                       | "MemoryError"                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ModuleNotFoundError"               | "ModuleNotFoundError"             |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_NameError"                         | "NameError"                       |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_NotADirectoryError"                | "NotADirectoryError"              |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_NotImplementedError"               | "NotImplementedError"             |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_OSError"                           | "OSError"                         | [1]        |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_OverflowError"                     | "OverflowError"                   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_PermissionError"                   | "PermissionError"                 |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ProcessLookupError"                | "ProcessLookupError"              |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_RecursionError"                    | "RecursionError"                  |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ReferenceError"                    | "ReferenceError"                  |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_RuntimeError"                      | "RuntimeError"                    |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_StopAsyncIteration"                | "StopAsyncIteration"              |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_StopIteration"                     | "StopIteration"                   |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_SyntaxError"                       | "SyntaxError"                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_SystemError"                       | "SystemError"                     |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_SystemExit"                        | "SystemExit"                      |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_TabError"                          | "TabError"                        |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_TimeoutError"                      | "TimeoutError"                    |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_TypeError"                         | "TypeError"                       |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnboundLocalError"                 | "UnboundLocalError"               |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeDecodeError"                | "UnicodeDecodeError"              |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeEncodeError"                | "UnicodeEncodeError"              |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeError"                      | "UnicodeError"                    |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeTranslateError"             | "UnicodeTranslateError"           |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ValueError"                        | "ValueError"                      |            |
+-------------------------------------------+-----------------------------------+------------+
| "PyExc_ZeroDivisionError"                 | "ZeroDivisionError"               |            |
+-------------------------------------------+-----------------------------------+------------+

Novo na versão 3.3: "PyExc_BlockingIOError", "PyExc_BrokenPipeError",
"PyExc_ChildProcessError", "PyExc_ConnectionError",
"PyExc_ConnectionAbortedError", "PyExc_ConnectionRefusedError",
"PyExc_ConnectionResetError", "PyExc_FileExistsError",
"PyExc_FileNotFoundError", "PyExc_InterruptedError",
"PyExc_IsADirectoryError", "PyExc_NotADirectoryError",
"PyExc_PermissionError", "PyExc_ProcessLookupError" and
"PyExc_TimeoutError" were introduced following **PEP 3151**.

Novo na versão 3.5: "PyExc_StopAsyncIteration" and
"PyExc_RecursionError".

Novo na versão 3.6: "PyExc_ModuleNotFoundError".

Esses são os aliases de compatibilidade para "PyExc_OSError":

+---------------------------------------+------------+
| Nome C                                | Notas      |
|=======================================|============|
| "PyExc_EnvironmentError"              |            |
+---------------------------------------+------------+
| "PyExc_IOError"                       |            |
+---------------------------------------+------------+
| "PyExc_WindowsError"                  | [2]        |
+---------------------------------------+------------+

Alterado na versão 3.3: Esses aliases costumavam ser tipos de exceção
separados.

Notas:

[1] Esta é uma classe base para outras exceções padrão.

[2] Defina apenas no Windows; proteja o código que usa isso testando
    se a macro do pré-processador "MS_WINDOWS" está definida.


Categorias de aviso padrão
==========================

All standard Python warning categories are available as global
variables whose names are "PyExc_" followed by the Python exception
name. These have the type PyObject*; they are all class objects. For
completeness, here are all the variables:

+--------------------------------------------+-----------------------------------+------------+
| Nome C                                     | Nome Python                       | Notas      |
|============================================|===================================|============|
| "PyExc_Warning"                            | "Warning"                         | [3]        |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_BytesWarning"                       | "BytesWarning"                    |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_DeprecationWarning"                 | "DeprecationWarning"              |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_FutureWarning"                      | "FutureWarning"                   |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_ImportWarning"                      | "ImportWarning"                   |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_PendingDeprecationWarning"          | "PendingDeprecationWarning"       |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_ResourceWarning"                    | "ResourceWarning"                 |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_RuntimeWarning"                     | "RuntimeWarning"                  |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_SyntaxWarning"                      | "SyntaxWarning"                   |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_UnicodeWarning"                     | "UnicodeWarning"                  |            |
+--------------------------------------------+-----------------------------------+------------+
| "PyExc_UserWarning"                        | "UserWarning"                     |            |
+--------------------------------------------+-----------------------------------+------------+

Novo na versão 3.2: "PyExc_ResourceWarning".

Notas:

[3] Esta é uma classe base para outras categorias de aviso padrão.
